// Скрипт исполняемый при загрузке прошивки Mongoose-os на микроконтроллере ESP8266
// описывается на Javascript с учетом допустимых комманд интерпретатором mjs (https://github.com/cesanta/mjs)
// для взаимодействия с интерфейсами микроконтроллера используются javascript-библиотеки Mongoose-os
// Скрипты помещаются при помощи Mongoose OS IDE на флеш-память микроконтроллера и при зашорузке компилируются его процессором в бинарный формат для дальнейшего запуска
//
load('api_gpio.js'); // подключение библиотеки для работы с пинам базового цифрового ввода/вывода (GPIO)
load('api_sys.js'); // подключение библиотеки исполнения системных комманд (к примеру sys.reboot())
load('api_timer.js'); // подключение библиотеки взаимодействия со встроенным таймером микропроцессора, реализующая взаимодействие с системным временем и создание цикличных функций с выполнением через определенный интервал времени (аналог функции setInterval() в "чистом" Javascript)
load('api_events.js'); // подключение библиотеки обработки внутрисистемных событий, mongoose-os реализует событийную модель взаимодействия с микроконтроллером ESP8266 
load('api_net.js'); // подключение библиотеки взаимодействия с сетевой подсистемой Mongoose OS (прошивка принимает на себя базовые функции по установлению и обработке процесса подключения к WiFi и конфигурации протоколов, для этого содержиться отдельный json config-файл в постоянной памяти микроконтроллера)
load('api_http.js'); // подключение библиотеки для работы c HTTP
// 
// Описываем основные переменные
let led = 2; // GPIO-пин встроенного светодиода 
let relay = 4; // GPIO-пин для подключения управляемого реле постоянного/переменного тока
let motion = 5; // GPIO-пин для подключения PIR-датчика движения 
let motionBlocked=0; // переменная для фиксации времени (в UNIX-time) до которого не обрабатывать события с датчика движения (введена для снижени бесполезных повторных отправок сообщений)
let evs = null; // переменная для фиксирования этапа подключения к сети
let ntfyUrl="http://us-central1-karim-alarm.cloudfunctions.net/notify?id=MainSensor0"; // HTTP URL для отправки уедомлений о фиксации движения PIR-датчиком
let stateUrl="https://karim-alarm.firebaseio.com/alarm/state.json"; // HTTP URL для чтения текущего "состояни сигнализации" (вкл/выкл)
let state=1; // Переменная состояния реле (по умолчанию ВКЛЮЧЕНО) 
// GPIO INIT
GPIO.set_mode(relay, GPIO.MODE_OUTPUT); // настраиваем GPIO-пин подключения реле в режим "выхода"
GPIO.set_mode(led, GPIO.MODE_OUTPUT); // настраиваем GPIO-пин фстроенного светодиода в режим "выхода" (стоит учитывать, что обработчки согнала на нем инвертный)
GPIO.set_mode(motion, GPIO.MODE_INPUT); // настраиваем GPIO-пин подключения датчика движения в режим "входа"
//
let cMotion=0; // переменная для фиксирования текущего сотояния датчика движения, будет использована двойной проверки состояния, с целью исключения "ложно-положительный сработок". По умолчанию - "движение не зафиксировано"
GPIO.write(relay, state); // включаем реле согласно состония по умолчанию, при помощи переменной state
// Functions
Timer.set(25000, Timer.REPEAT, function (){ // Обьявляем "таймер" согласно спецификаии API mongoose os(https://mongoose-os.com/docs/reference/api.html), для повторяющегося выполнения функции с интервалом в 25секунд
    if (evs === 'GOT_IP'){ // если переменная свидетельствует об успешном подключении к сети (получен IP-адрес по DHCP-протоколу)
        HTTP.query({ // выполняем HTTP-функцию для отправки запроса к базе данных о состоянии сигнализации
            url:stateUrl, // определяем URL, по которому следует отправить GET-запрос; так как в переменной был использован URL с SSL-защищенного соединения HTTPS, для обработки подлинности сертификата сервера, последний следует добавить в файл ca.pem содержащийся во флеш-памяти
            success: function(b,h){ state=(b==="true")? 1:0; GPIO.write(relay,state); }, // при "успешном" (code:200 OK) выполнении запроса, переменная state принимает занчение 1, если в ответ сервера содержал true, или 0;
            // Снова выставляется сигнал подаваемый на реле, согласно обновленного состояния переменной state
            //
            error: function(err){ sys.reboot(); } // в случае любой ошибки при запросе состояния сигнализации - перезагрузить микроконтроллер
        });
    } else { sys.reboot(); } // если к моменту запуска функции (25секунд после загрузки) IP-адрес так и не был получен в сети - перезагрузить микроконтроллер
},null);
function ntfy(){ // объявляем функцию для отправки запроса в проект на платформе Firebase Cloud Functions, которая выполнит отправку уведомлений пользователям 
  if (evs === 'GOT_IP' && state){ // условием запуска функции будут два критерия - переменная evs подтвердает наличие полноценного подключения к сети и переменная state положительная (в нашем случае равна 1)
    HTTP.query({ // создаем HTTP GET-запрос с облачнай функции на отправку уведомлений клиентам  
      url: ntfyUrl, // определяем URL, по которому следует осуществить запрос (изначально при объявлении переменной в query часть URI определена переменная id с идентификатором "датчика", что будет указан в теле PUSH-сообщения)
      success: function(b,h){ GPIO.write(led, false); } // при успешном завершении запроса включить светодиод
      // поведение при выходе функции с ошибкой не обрабатываем - так как в данной ситуации датчик больше ничего не сможет предпринять, а повторное определение движения инициирует эту функцию снова
    });
  }
}
//handle motion
Timer.set(250, Timer.REPEAT, function (){ // Объявляем фугкцию с цикличным выполнением каждые четверть секунды
  if(evs !== 'GOT_IP') { // если переменная не приняля значение GOT_IP - значит процесс подключения к сети не завершился, или был не успешен
    GPIO.toggle(led); //измененя состояни светодиода (за счет выполнения этой операции каждые 250мс, создается визуальное восприятие "мигание светодиода во время подключения к сети")
  }
  if (GPIO.read(motion)!==cMotion && motionBlocked<Timer.now()){ // для принятия решения о необходимости отправки уведомления на сервер функции Firebase проверяется два критерия
    // 1. Полученное состояние на "ноге" подключения датчика движения должно отличаться от "текущего", записанного в переменную cMotion в предыдущую итерацию проверки
    // 2. Timestamp записанный в переменную motionBlocked должен быть меньше текущего системного времени (в формате unixtime)
    //
    cMotion=GPIO.read(motion); // повторно вычитываем состоние пина сенасора движения, так как операция произойдет с повторно с интервалом менее 1мс это позволит отбросить вероятность ложной сработки из-за "наводки" или сбоя датчика
    GPIO.write(led,(1-cMotion)); // Так как светодиод принимает инвертное значения (дл свечения - 0, откл - 1), выставляем сигнал на его пин обратный сигналу полученному от датчика движени - т.е. "светит при движении"
    if (cMotion) { // Если переменная положительная (т.е. повторная проверка подтвердила фиксацию движения датчиком) переходим к отправке уведомлений
        ntfy();  // вызываем ранее объявленную функцию отправки уведомлений в проект на платформе Firebase для дальнейшего получения уведомлений клиентами
        motionBlocked=Timer.now()+30; // для снижения "бесполезных уведомлений" записываем в переменную текущий timestamp в формате unixtime придавив 30, что заблокирует процедуру "фиксации двжения" на 30секунд, согласно выше описанного критерия
    }   
  }
},null);
// Monitor network connectivity.
Event.addGroupHandler(Net.EVENT_GRP, function(ev, evdata, arg) { // Добавляем обработчик событий от сетевой подсистемы 
  // исходя из документированных состояний события, определяем критерии при которых изменяется значение переменной evs
  if (ev === Net.STATUS_DISCONNECTED) {
    evs = 'DISCONNECTED'; // сетевая подсистема сообщила об отключении от WiFi-сети
  } else if (ev === Net.STATUS_CONNECTING) {
    evs = 'CONNECTING'; // сетевая подсистема сообщила о начале установки подключения к WiFi-сети (согласно параметров config-файла, что создается Mongoose-os IDE при инициализации проекта)
  } else if (ev === Net.STATUS_CONNECTED) {
    evs = 'CONNECTED'; // сетевая подсистема сообщила о наличии успешного подключения к WiFi-сети
  } else if (ev === Net.STATUS_GOT_IP) {
    evs = 'GOT_IP'; // сетевая подсистема сообщила о завершении настроки подключения к IP-сети (после CONNECTED бфл получен ответ DHCP-сервера и сконфигурирован IP-интерфейс)
  }
  print('== Net event:', ev, evs); // Вывод текущего состояния подключения к сети в UART-интерфей (консоль) микроконтроллера
}, null);
